<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Pro Universe Simulator | 3D Space Engine</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: 'Orbitron', sans-serif; overflow: hidden; }
        canvas { display: block; }

        /* Advanced Sci-Fi UI */
        #gui-container {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 20, 40, 0.7);
            padding: 20px; border: 1px solid #00ffff;
            border-radius: 10px; backdrop-filter: blur(5px);
            width: 300px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        h1 { font-size: 18px; color: #00ffff; text-transform: uppercase; margin: 0 0 10px 0; border-bottom: 1px solid #00ffff; padding-bottom: 5px; }
        
        .info-box { font-size: 12px; line-height: 1.5; color: #add8e6; }
        .control-panel { margin-top: 15px; border-top: 1px solid #333; pt: 10px; }
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-family: monospace; }
        .label { color: #888; }
        .value { color: #fff; }

        #planet-display {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none;
        }
        #p-title { font-size: 40px; font-weight: bold; text-transform: uppercase; letter-spacing: 10px; color: rgba(255,255,255,0.5); }

        #sidebar {
            position: absolute; right: 0; top: 0; bottom: 0;
            width: 60px; background: rgba(0,0,0,0.8);
            border-left: 1px solid #333; display: flex; flex-direction: column;
            align-items: center; padding-top: 20px;
        }
        .icon-btn { 
            width: 40px; height: 40px; margin-bottom: 20px; 
            border: 1px solid #444; border-radius: 5px; 
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: 0.3s;
        }
        .icon-btn:hover { background: #00ffff; color: #000; }

        /* Loading Screen */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #111 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10000;
        }
        .scanner {
            width: 200px; height: 2px; background: #00ffff;
            box-shadow: 0 0 15px #00ffff; animation: scan 2s infinite;
        }
        @keyframes scan { 0% { transform: translateY(-20px); } 50% { transform: translateY(20px); } 100% { transform: translateY(-20px); } }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="loader">
        <h2 style="letter-spacing: 5px; color: #00ffff;">SYSTEM INITIALIZING</h2>
        <div class="scanner"></div>
        <p style="margin-top: 20px; font-size: 12px; color: #444;">CALIBRATING ORBITAL PATHS...</p>
    </div>

    <div id="gui-container">
        <h1>Universe Engine v3.0</h1>
        <div class="info-box">
            <div class="stat-row"><span class="label">Status:</span><span class="value" style="color: #0f0;">ACTIVE</span></div>
            <div class="stat-row"><span class="label">Entities:</span><span class="value">15,000+ Objects</span></div>
            <div class="stat-row"><span class="label">Time:</span><span class="value" id="current-time">Real-time</span></div>
        </div>
        <div class="control-panel">
            <p style="font-size: 10px; color: #00ffff;">OBJECT TRACKING:</p>
            <div id="object-list" style="font-size: 11px; max-height: 200px; overflow-y: auto;">
                <!-- Dynamically filled -->
            </div>
        </div>
    </div>

    <div id="planet-display">
        <div id="p-title">SOLAR SYSTEM</div>
    </div>

    <div id="sidebar">
        <div class="icon-btn" title="View Sun">‚òÄÔ∏è</div>
        <div class="icon-btn" title="View Earth">üåç</div>
        <div class="icon-btn" title="View ISS">üì°</div>
        <div class="icon-btn" title="Reset Camera">üîÑ</div>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        /**
         * UNIVERSE SIMULATOR - ADVANCED ARCHITECTURE
         * Logic is divided into specialized modules for Planets, Moons, and Satellites.
         */

        let scene, camera, renderer, controls, clock;
        const planets = [];
        const moons = [];
        const satellites = [];
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();

        // --- 1. CONFIGURATION ---
        const CONFIG = {
            orbitSpeed: 0.5,
            rotationSpeed: 1,
            showLabels: true,
            cameraLerp: 0.05
        };

        // --- 2. CLASS DEFINITIONS ---

        class CelestialBody {
            constructor(name, size, distance, speed, color, parent = scene) {
                this.name = name;
                this.size = size;
                this.distance = distance;
                this.speed = speed;
                this.angle = Math.random() * Math.PI * 2;

                // Group for orbit
                this.orbitGroup = new THREE.Group();
                parent.add(this.orbitGroup);

                // Mesh
                const geometry = new THREE.SphereGeometry(size, 64, 64);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    shininess: 10,
                    emissive: color,
                    emissiveIntensity: 0.1
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.x = distance;
                this.orbitGroup.add(this.mesh);

                // Orbit Ring
                this.createOrbitRing();
            }

            createOrbitRing() {
                const curve = new THREE.EllipseCurve(0, 0, this.distance, this.distance);
                const points = curve.getPoints(100);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.3 });
                const orbitLine = new THREE.Line(geometry, material);
                orbitLine.rotation.x = Math.PI / 2;
                scene.add(orbitLine);
            }

            update(delta) {
                this.angle += this.speed * CONFIG.orbitSpeed * delta;
                this.orbitGroup.rotation.y = this.angle;
                this.mesh.rotation.y += 0.01 * CONFIG.rotationSpeed;
            }
        }

        class Moon extends CelestialBody {
            constructor(name, size, distance, speed, color, planetMesh) {
                super(name, size, distance, speed, color, planetMesh);
                // Moons are attached to planetMesh
                this.planetMesh = planetMesh;
            }
            // Override update to stay near planet
            update(delta) {
                this.angle += this.speed * delta;
                this.orbitGroup.rotation.y = this.angle;
            }
        }

        class Satellite {
            constructor(planetMesh) {
                this.group = new THREE.Group();
                planetMesh.add(this.group);
                
                // Simple Satellite Shape (Box + Wings)
                const coreGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const wingGeo = new THREE.BoxGeometry(0.8, 0.05, 0.3);
                const mat = new THREE.MeshPhongMaterial({ color: 0xcccccc, shininess: 100 });
                
                const core = new THREE.Mesh(coreGeo, mat);
                const wing1 = new THREE.Mesh(wingGeo, mat);
                wing1.position.x = 0.5;
                const wing2 = new THREE.Mesh(wingGeo, mat);
                wing2.position.x = -0.5;
                
                this.group.add(core, wing1, wing2);
                this.group.position.x = 2.5; // Orbit height above Earth
                this.angle = 0;
            }
            update(delta) {
                this.angle += 0.02;
                this.group.rotation.x = this.angle;
                this.group.rotation.z += 0.01;
            }
        }

        // --- 3. CORE ENGINE ---

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();

            // Camera & Renderer
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 200, 500);

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambient = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambient);

            createSun();
            createUniverse();
            buildSolarSystem();
            createComet();

            // Event Listeners
            window.addEventListener('resize', onResize);
            document.addEventListener('mousedown', onPointerDown);

            animate();

            // Remove Loader
            setTimeout(() => {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').remove(), 1000);
            }, 2500);
        }

        function createSun() {
            // Sun Mesh
            const sunGeo = new THREE.SphereGeometry(25, 64, 64);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            scene.add(sun);

            // Light from Sun
            const sunLight = new THREE.PointLight(0xffffff, 2.5, 2000);
            scene.add(sunLight);

            // Sun Glow (Shader-like effect)
            for(let i = 1; i <= 3; i++) {
                const spriteGeo = new THREE.SphereGeometry(25 + (i*5), 64, 64);
                const spriteMat = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.3 / i,
                    side: THREE.BackSide
                });
                scene.add(new THREE.Mesh(spriteGeo, spriteMat));
            }
        }

        function buildSolarSystem() {
            const data = [
                { name: "Mercury", size: 1, dist: 50, speed: 1.5, color: 0x888888 },
                { name: "Venus", size: 1.8, dist: 80, speed: 1.1, color: 0xe3bb76 },
                { name: "Earth", size: 2, dist: 120, speed: 0.8, color: 0x2277ff, hasMoon: true, hasSatellite: true },
                { name: "Mars", size: 1.4, dist: 160, speed: 0.6, color: 0xff4422 },
                { name: "Jupiter", size: 8, dist: 250, speed: 0.3, color: 0xffa500, moons: 4 },
                { name: "Saturn", size: 7, dist: 350, speed: 0.2, color: 0xdfd195, hasRings: true },
                { name: "Uranus", size: 4, dist: 450, speed: 0.1, color: 0x88ddff },
                { name: "Neptune", size: 4, dist: 520, speed: 0.08, color: 0x3355ff }
            ];

            const list = document.getElementById('object-list');

            data.forEach(d => {
                const p = new CelestialBody(d.name, d.size, d.dist, d.speed, d.color);
                planets.push(p);

                // Add to UI list
                const item = document.createElement('div');
                item.style.padding = '5px';
                item.style.cursor = 'pointer';
                item.innerHTML = `> ${d.name.toUpperCase()}`;
                item.onclick = () => focusObject(p.mesh, d.name);
                list.appendChild(item);

                // Add Earth's Moon
                if(d.hasMoon) {
                    const m = new Moon("Moon", 0.4, 4, 0.5, 0xaaaaaa, p.mesh);
                    moons.push(m);
                }

                // Add Satellites to Earth
                if(d.hasSatellite) {
                    const sat = new Satellite(p.mesh);
                    satellites.push(sat);
                }

                // Add Jupiter's Moons
                if(d.moons) {
                    for(let i=0; i<d.moons; i++) {
                        moons.push(new Moon("JMoon"+i, 0.3, 10 + (i*2), 0.2 + (i*0.1), 0xffffff, p.mesh));
                    }
                }

                // Add Saturn Rings
                if(d.hasRings) {
                    const ringGeo = new THREE.RingGeometry(9, 15, 64);
                    const ringMat = new THREE.MeshBasicMaterial({ color: 0x998877, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI/2.5;
                    p.mesh.add(ring);
                }
            });
        }

        function createUniverse() {
            // Starfield (10,000 stars)
            const starGeo = new THREE.BufferGeometry();
            const starCount = 15000;
            const starPos = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) {
                starPos[i] = (Math.random() - 0.5) * 3000;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ size: 1, color: 0xffffff, transparent: true, opacity: 0.8 });
            scene.add(new THREE.Points(starGeo, starMat));

            // Asteroid Belt
            const astCount = 3000;
            const astGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const astMat = new THREE.MeshPhongMaterial({ color: 0x777777 });
            const astGroup = new THREE.Group();
            for(let i=0; i<astCount; i++) {
                const mesh = new THREE.Mesh(astGeo, astMat);
                const r = 190 + Math.random() * 30;
                const a = Math.random() * Math.PI * 2;
                mesh.position.set(Math.cos(a)*r, (Math.random()-0.5)*5, Math.sin(a)*r);
                astGroup.add(mesh);
            }
            scene.add(astGroup);
            window.asteroidBelt = astGroup;
        }

        function createComet() {
            const cometGeo = new THREE.SphereGeometry(0.2, 8, 8);
            const cometMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const comet = new THREE.Mesh(cometGeo, cometMat);
            scene.add(comet);

            // Tail effect
            const tailPoints = [];
            for(let i=0; i<20; i++) tailPoints.push(new THREE.Vector3(0,0,0));
            const tailGeo = new THREE.BufferGeometry().setFromPoints(tailPoints);
            const tailMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
            const tail = new THREE.Line(tailGeo, tailMat);
            scene.add(tail);

            window.comet = { mesh: comet, tail: tail, angle: 0 };
        }

        // --- 4. INTERACTION & ANIMATION ---

        function focusObject(target, name) {
            document.getElementById('p-title').innerText = name;
            const targetPos = new THREE.Vector3();
            target.getWorldPosition(targetPos);
            
            new TWEEN.Tween(camera.position)
                .to({ x: targetPos.x + 20, y: targetPos.y + 10, z: targetPos.z + 20 }, 2000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
            
            controls.target.copy(targetPos);
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planets.map(p => p.mesh));
            if(intersects.length > 0) {
                const obj = intersects[0].object;
                focusObject(obj, "IDENTIFIED");
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            const delta = clock.getDelta();
            requestAnimationFrame(animate);
            TWEEN.update();

            // Update Planets
            planets.forEach(p => p.update(delta));
            
            // Update Moons
            moons.forEach(m => m.update(delta));

            // Update Satellites
            satellites.forEach(s => s.update(delta));

            // Update Asteroid Belt
            if(window.asteroidBelt) window.asteroidBelt.rotation.y += 0.0002;

            // Update Comet
            if(window.comet) {
                window.comet.angle += 0.005;
                const c = window.comet;
                c.mesh.position.set(Math.cos(c.angle)*400, Math.sin(c.angle)*100, Math.sin(c.angle)*400);
            }

            // Update UI
            document.getElementById('current-time').innerText = new Date().toLocaleTimeString();

            controls.update();
            renderer.render(scene, camera);
        }

        // Start everything
        init();

    </script>
</body>
  </html>
